[{"content":"Overview In this Blog Post I want to show how I enabled Private Endpoint for my Azure Arc Enabled Servers Step by Step. This Blog Post will cover up the Topic Virtual Network Gateway, DNS Private Resolver and changing existing Server from Public Endpoint to Private Endpoints.\n","permalink":"http://localhost:1313/hugo-PaperMod/posts/20240903/20240903_azurearc_privateendpoint/","summary":"Overview In this Blog Post I want to show how I enabled Private Endpoint for my Azure Arc Enabled Servers Step by Step. This Blog Post will cover up the Topic Virtual Network Gateway, DNS Private Resolver and changing existing Server from Public Endpoint to Private Endpoints.","title":"Azure Arc - Private Endpoint"},{"content":"Overview Azure Arc version 1.41 introduces certificate-based authentication for connecting and disconnecting servers, replacing the old method of using passwords. This new feature makes managing servers easier and more secure.\nIn this article, I will explain how to set up and use certificates for Azure Arc-enabled servers. You will learn how to create a certificate using Active Directory Certificate Services, export the certificate, and use it for onboarding servers to Azure Arc. Additionally, I will cover common issues you might face and suggest ways to improve the process.\nBy the end of this guide, you will be able to use certificates to securely manage and onboard your servers to Azure Arc.\nWhy Use Certificates Instead of Secrets? Previously, secrets were used for onboarding Azure Arc-enabled servers. However, certificates offer several advantages:\nSimplified Management: No need to remember or manage complex passwords. Centralized Control: Certificates can be centrally managed, and revocation can be used to disable them. Enhanced Security: Certificates support a zero-trust architecture by requiring verification at each step. Create a Certificate Active Directory Certificate Services To create a certificate for onboarding, we will use an internal Active Directory Certificate Services (AD CS) infrastructure. AD CS is a Windows Server role for issuing and managing a public key infrastructure (PKI), which creates, manages, distributes, stores, and revokes digital certificates.\nFor more information, visit: Active Directory Certificate Services Overview\nCreate a Certificate Template With your Certificate Authority ready, open the Certification Authority Console.\nManage Certificate Templates:\nOpen up the Certificate Authority Management Console. Click on \u0026ldquo;Certificates Templates\u0026rdquo; and then \u0026ldquo;Manage\u0026rdquo;. Duplicate the Computer Template:\nFind the existing Computer Template, right-click on it, and select \u0026ldquo;Duplicate Template\u0026rdquo;. Configure the New Template:\nChoose the highest available Certificate Authority. Under Certificate Recipient, ensure it is set for the lowest Member of your Domain. If you still have Windows Server 2012 R2 in your Environment you need to choose Windows Server 2012 R2 and shame on you! Set General Properties:\nName your template and publish the certificate in Active Directory. Request Handling:\nSelect \u0026ldquo;Allow private key to be exported\u0026rdquo;. Cryptography Settings:\nChoose Key Storage Provider as the Provider Category. Set the Request Hash to SHA512. Click \u0026ldquo;Apply\u0026rdquo;. Issue the Certificate Template:\nIn the Certificate Authority MMC, right-click on Certificate Template, select \u0026ldquo;New\u0026rdquo;, then \u0026ldquo;Certificate Template to Issue\u0026rdquo;. Select your newly created Certificate Template and click \u0026ldquo;OK\u0026rdquo;. Now we have created a Certificate Template in our Active Directory Certificate Authority which we can use for creating a Certificate.\nCreate a Certificate Using the Template Use a server or client that is a member of your Active Directory domain.\nOpen Certificate Console:\nRun certlm.msc to open the Certificate Console in Computer Context. certlm.msc Request a New Certificate:\nNavigate to Personal \u0026gt; Certificates \u0026gt; All Tasks \u0026gt; Request New Certificate. Certificate Enrollment:\nClick \u0026ldquo;Next\u0026rdquo;. Select \u0026ldquo;Active Directory Enrollment Policy\u0026rdquo; and click \u0026ldquo;Next\u0026rdquo;. Choose the template you created and click \u0026ldquo;Enroll\u0026rdquo;. Exporting the Certificate Return to the Personal Certificate Store of your computer.\nIdentify and Export the Certificate:\nRight-click on the certificate, select \u0026ldquo;All Tasks\u0026rdquo;, then \u0026ldquo;Export\u0026rdquo;. Export Options:\nClick \u0026ldquo;Next\u0026rdquo;. Select \u0026ldquo;Yes, export the private key\u0026rdquo; and click \u0026ldquo;Next\u0026rdquo;. Choose \u0026ldquo;Personal Information Exchange - PKCS #12 (.PFX)\u0026rdquo; and click \u0026ldquo;Next\u0026rdquo;. User Selection:\nEnter a Password of your Choice and select AES256-SHA256 as your Encryption and click \u0026ldquo;Next\u0026rdquo;. Complete the Export:\nChoose a file name and click \u0026ldquo;Next\u0026rdquo;. Click \u0026ldquo;Finish\u0026rdquo;. Repeat Without Exporting the Private Key:\nPerform the export again, but select \u0026ldquo;No, do not export the private key\u0026rdquo;.\nNow you should have both a .CER and a .PFX file.\nService Principal for Onboarding In this step, we will create a Service Principal for onboarding Azure Arc-enabled servers. A Service Principal is used for authentication during this process.\nSwitch to the Azure Portal.\nNavigate to Azure Arc:\nClick on \u0026ldquo;Service Principals\u0026rdquo; and then click \u0026ldquo;Add\u0026rdquo;. Define the Service Principal:\nEnter a name for your Azure Arc Service Principal. Select the scope for the Service Principal. Set Client Secret Details:\nChoose a description and an expiration date for the client secret (note: we will delete this later). Select the role \u0026ldquo;Azure Connected Machine Onboarding\u0026rdquo;. Click \u0026ldquo;Create\u0026rdquo;. Manage the Service Principal:\nGo to the created Service Principal, click on \u0026ldquo;Certificates \u0026amp; secrets,\u0026rdquo; then click on \u0026ldquo;Client secrets.\u0026rdquo; Click on the trash icon to delete the client secret. Upload Certificate:\nClick on \u0026ldquo;Certificates\u0026rdquo; and then click \u0026ldquo;Upload Certificate.\u0026rdquo; Upload the certificate and click \u0026ldquo;Add.\u0026rdquo; Onboarding the Server Finally, we proceed to onboard the server But I failed\nConvert the Certificate from .PFX to .PEM: Convert the .PFX File to a .PEM File. You can use openSSL for the conversion. INFO: On a Windows Client you can use openSSL if you have Git installed on your Client.\nCopy the Certificate:\nTransfer the .PEM file to the Windows server you wish to onboard to Azure Arc. cd \u0026#39;C:\\Program Files\\Git\\usr\\bin\\\u0026#39; .\\openssl.exe pkcs12 -in \u0026#34;C:\\Users\\PratheepSinnathurai\\Downloads\\test.pfx\u0026#34; -out \u0026#34;C:\\Users\\PratheepSinnathurai\\Downloads\\test.pem\u0026#34; -nodes Install the Azure Arc Agent:\nRun the following PowerShell command to install the Azure Arc Agent on the Windows server: # Download the installation package Invoke-WebRequest -UseBasicParsing -Uri \u0026#34;https://aka.ms/azcmagent-windows\u0026#34; -TimeoutSec 30 -OutFile \u0026#34;$env:TEMP\\install_windows_azcmagent.ps1\u0026#34;; # Install the hybrid agent \u0026amp; \u0026#34;$env:TEMP\\install_windows_azcmagent.ps1\u0026#34;; if ($LASTEXITCODE -ne 0) { exit 1; } # Define parameters $servicePrincipalCertPath = \u0026#34;C:\\temp\\test.pfx\u0026#34; $servicePrincipalId = \u0026#34;befa049d-f87d-4362-95d2-a03728c80959\u0026#34; $tenantId = \u0026#34;5e6d7959-d83c-418e-bc9a-c1766178f93d\u0026#34; $location = \u0026#34;switzerlandnorth\u0026#34; $resourceGroup = \u0026#34;rg-azurearc-arclz-prd-szn-01\u0026#34; $subscriptionId = \u0026#34;58383638-826b-42fb-bc5b-e07f4ef489e5\u0026#34; $tags = \u0026#34;UpdateGroup=A1\u0026#34; # Construct the command $azcmagentConnectCmd = \u0026#34;azcmagent connect --service-principal-cert `\u0026#34;$servicePrincipalCertPath`\u0026#34; --service-principal-id $servicePrincipalId --tenant-id $tenantId --location $location --resource-group $resourceGroup --subscription-id $subscriptionId --tags $tags\u0026#34; # Execute the command Invoke-Expression $azcmagentConnectCmd Confirming\nAt the end we see that the server was successfully onboarded.\nTroubleshooting When I was testing this feature, I encountered some failures that I\u0026rsquo;d like to show you.\n.PFX File In my first test I used the .PFX File instead of the .PEM File.\nIn the documentation, it is mentioned that password-protected .PFX files were not working.\nTherefore, I tested out the .PFX file with the permission \u0026ldquo;Everyone\u0026rdquo; (don\u0026rsquo;t do that in production).\nI received the following error message:\nPath to the .PFX File Let\u0026rsquo;s say we have our Certificate ready and I like to deploy that Certificate to multiple Servers. I would use a Group Policy to deploy my Certificate into the Personal Certificate Store and would run the azcmagent connect Command refering to my Personal Certificate Store.\nIn my opininon we should be able to reference to the Certificates which are in the Certiciate Personal Store.\nImprovements After testing certificate-based authentication for Azure Arc-enabled server onboarding, I recommend the following improvements for Microsoft:\nIt would be great if we could have more insights on how to create and manage the Certificate for Onboarding. Enable linking certificates from the Certificate Store rather than relying on file storage. This would make the deployment of certificates across all Windows Servers for Azure Arc onboarding easier. Simplify the creation of Azure Arc Service Principals in the Azure Portal by enabling direct use of a certificate, eliminating the current requirement to provide a client secret. Conclusion In conclusion, Azure Arc version 1.41 brings a valuable new feature: certificate-based authentication for onboarding servers. This change makes the process more secure by using certificates instead of passwords, making it easier to manage and control access centrally.\nThis article provided a step-by-step guide on how to create and use certificates for Azure Arc. We covered setting up Active Directory Certificate Services, creating a certificate template, exporting the certificates, and creating a service principal for Azure Arc. We also discussed common problems and improvements needed to make the process smoother.\nOverall, using certificates instead of passwords for Azure Arc onboarding is a big improvement. It simplifies the process and enhances security. With continued updates and user feedback, Microsoft can make Azure Arc even easier and more secure to use for managing servers.\n","permalink":"http://localhost:1313/hugo-PaperMod/posts/20240606/20240529_azurearconboarding/","summary":"Overview Azure Arc version 1.41 introduces certificate-based authentication for connecting and disconnecting servers, replacing the old method of using passwords. This new feature makes managing servers easier and more secure.\nIn this article, I will explain how to set up and use certificates for Azure Arc-enabled servers. You will learn how to create a certificate using Active Directory Certificate Services, export the certificate, and use it for onboarding servers to Azure Arc.","title":"Certificate-Based Onboarding for Azure Arc Servers"},{"content":"Overview Since May 2024, I have been a Microsoft MVP in Azure Hybrid and Migration. Many people have asked me, \u0026ldquo;Hey Pratheep, how did you start your blog?\u0026rdquo; To avoid spending too much time on questions like \u0026ldquo;How should my page look?\u0026rdquo; and \u0026ldquo;Which font should I use?\u0026rdquo; I initially published my first blogs on Medium.com. However, I always wanted to create my own blog site.\nRecently, I noticed that some Microsoft-provided websites were using Hugo, a tool I hadn\u0026rsquo;t heard of before. Intrigued, I decided to invest some time in learning and experimenting with Hugo. In this blog post, I will show you how to create your own blog using Hugo and Azure Static Web Apps. The best part? It\u0026rsquo;s all free.\nWhat is Hugo Hugo is a popular open-source static site generator written in Go. It allows you to create fast and flexible websites effortlessly. With Hugo, you can author content in Markdown or HTML and generate a static website that can be hosted on any web server.\nOne issue that bothered me on Medium.com was the incorrect formatting of PowerShell command syntax. With Hugo, I can use Markdown, which provides better support for coding syntax.\nI discovered Hugo when I learned that Microsoft\u0026rsquo;s Azure Verified Module Website was built using it. Intrigued by its capabilities, I decided to give Hugo a try myself.\nInstallation Hugo To get started with Hugo, you\u0026rsquo;ll need to install it on your machine. I used a Windows 11 device. On Windows 11, you can use WinGet to install Hugo:\nwinget install -e --id Hugo.Hugo.Extended Create a Hugo App Now that we have Hugo installed, we can use the Hugo CLI to create a new app:\nhugo new site techblog Navigate to the newly created Hugo app directory:\ncd .\\techblog\\ Initialize a new local Git repository:\ngit init Rename the current branch to \u0026ldquo;main\u0026rdquo;:\ngit branch -M main Now, let\u0026rsquo;s select a theme for your new website. You can browse a complete list of available themes here: Hugo Themes.\nIf you want to customize a theme, you can fork it and make your modifications. Alternatively, you can update the theme whenever the repository is updated.\nPersonally, I prefer the GitHub Style theme, so I chose that one. To add the GitHub Style theme as a submodule to your current Git repository and place it in the themes/github-style directory, use the following command:\ngit submodule add https://github.com/MeiK2333/github-style themes/github-style In the hugo.toml file, change the theme to the new theme:\ntheme = \u0026#34;github-style\u0026#34; Commit the changes:\ngit add -A git commit -m \u0026#34;first commit\u0026#34; Deploy Your Hugo App to GitHub To save and later deploy our Hugo app, we\u0026rsquo;ll create a GitHub repository. If you don\u0026rsquo;t have a GitHub account yet, you can create one here.\nCreate a new repository using this link. You can choose to make it public or private.\nAdd your GitHub repository as a remote to your local repository. Replace the URL with your GitHub repository\u0026rsquo;s URL:\ngit remote add origin https://github.com/psinnathurai/techblog Push your local repository to your remote repository:\ngit push --set-upstream origin main Deploy a New Static Web App Troubleshooting We could easily create a Static Web App in Azure using the portal, but I prefer to use Bicep to deploy our Azure resources. After some testing, I was NOT able to create the Static Web App using Bicep, but I will show you where I encountered issues.\nPlease do not follow the next steps until I mention it\u0026rsquo;s safe again.\nFirst, use the following Bicep file and parameter file to create a Web App:\nmain.bicep:\nparam name string param location string param sku string param repositoryUrl string param branch string param appLocation string param apiLocation string param appArtifactLocation string param areStaticSitesDistributedBackendsEnabled bool module staticSite \u0026#39;br/public:avm/res/web/static-site:0.3.0\u0026#39; = { name: name params: { name: name location: location sku: sku repositoryUrl: repositoryUrl branch: branch appSettings: { APP_LOCATION: appLocation API_LOCATION: apiLocation APP_ARTIFACT_LOCATION: appArtifactLocation ARE_STATIC_SITES_DISTRIBUTED_BACKENDS_ENABLED: areStaticSitesDistributedBackendsEnabled } } } params.bicep:\nusing \u0026#39;./main.bicep\u0026#39; @description(\u0026#39;The name of the static site\u0026#39;) param name = \u0026#39;sinnathuraitechblog\u0026#39; @description(\u0026#39;The location of the static site\u0026#39;) param location = \u0026#39;westeurope\u0026#39; @description(\u0026#39;The SKU of the static site\u0026#39;) param sku = \u0026#39;Free\u0026#39; @description(\u0026#39;The repository URL of the static site\u0026#39;) param repositoryUrl = \u0026#39;https://github.com/psinnathurai/techblog\u0026#39; @description(\u0026#39;The branch of the repository for the static site\u0026#39;) param branch = \u0026#39;main\u0026#39; @description(\u0026#39;The app location for the static site\u0026#39;) param appLocation = \u0026#39;/\u0026#39; @description(\u0026#39;The API location for the static site\u0026#39;) param apiLocation = \u0026#39;\u0026#39; @description(\u0026#39;The app artifact location for the static site\u0026#39;) param appArtifactLocation = \u0026#39;public\u0026#39; @description(\u0026#39;Whether distributed backends are enabled for the static site\u0026#39;) param areStaticSitesDistributedBackendsEnabled = false Once our Static Web App in the Azure portal is ready, we need to copy the deployment token for authentication in GitHub.\nCopy the deployment token:\nGo to your previously created GitHub repository. Click on Settings. Under Secrets and variables, click on Actions. Add a repository secret named AZURE_STATIC_WEB_APPS_API_TOKEN and use the copied deployment token as the value.\nFor automation, add a GitHub Action that will run when there is a new change in the repository and publish the latest update to our website.\nClick on Actions. Create a new workflow. Paste the YAML code below. name: Azure Static Web Apps CI/CD on: push: branches: - main pull_request: types: [opened, synchronize, reopened, closed] branches: - main jobs: build_and_deploy_job: if: github.event_name == \u0026#39;push\u0026#39; || (github.event_name == \u0026#39;pull_request\u0026#39; \u0026amp;\u0026amp; github.event.action != \u0026#39;closed\u0026#39;) runs-on: ubuntu-latest name: Build and Deploy Job steps: - uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 lfs: false - name: Build And Deploy id: builddeploy uses: Azure/static-web-apps-deploy@v1 with: azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }} repo_token: ${{ secrets.GITHUB_TOKEN }} # Used for Github integrations (i.e. PR comments) action: \u0026#34;upload\u0026#34; ###### Repository/Build Configurations - These values can be configured to match your app requirements. ###### # For more information regarding Static Web App workflow configurations, please visit: https://aka.ms/swaworkflowconfig app_location: \u0026#34;/\u0026#34; # App source code path api_location: \u0026#34;\u0026#34; # Api source code path - optional output_location: \u0026#34;public\u0026#34; # Built app content directory - optional ###### End of Repository/Build Configurations ###### close_pull_request_job: if: github.event_name == \u0026#39;pull_request\u0026#39; \u0026amp;\u0026amp; github.event.action == \u0026#39;closed\u0026#39; runs-on: ubuntu-latest name: Close Pull Request Job steps: - name: Close Pull Request id: closepullrequest uses: Azure/static-web-apps-deploy@v1 with: azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }} action: \u0026#34;close\u0026#34; After the workflow runs, I received the following error:\nI couldn\u0026rsquo;t find a solution for this issue. I suspect it might be because, in the Azure portal, we can specify that we\u0026rsquo;re using Hugo, which isn\u0026rsquo;t possible in the Bicep deployment for a Static Web App.\nUsing the Azure Portal It is now safe to follow these steps.\nNow, we\u0026rsquo;ll create the static website in the Azure portal.\nGo to the Azure Portal. Search for \u0026ldquo;Static Web Apps\u0026rdquo;. Click on \u0026ldquo;Create\u0026rdquo;. Select the subscription and the resource group. Enter the name. Select \u0026ldquo;Free\u0026rdquo; as the plan type. Choose GitHub as the source and select your GitHub account (the deployment token will be added to the repository in the background). Select the organization, repository, and branch. Under \u0026ldquo;Build Presets,\u0026rdquo; select Hugo. This step is missing in the Bicep deployment for a Static Web App. Click \u0026ldquo;Review and Create\u0026rdquo; and then \u0026ldquo;Create\u0026rdquo;.\nWait until the GitHub Action runs are finished. You can check the status of the actions in the GitHub repository under Actions.\nConclusion Creating your own blog using Hugo and Azure Static Web Apps is both straightforward and rewarding. By leveraging Hugo\u0026rsquo;s static site generation and Azure\u0026rsquo;s hosting solutions, you can build and deploy a professional blog with ease. This method gives you greater control over your site\u0026rsquo;s appearance and functionality, ensuring fast performance and flexibility.\nIn this guide, we covered the steps to install Hugo, create a new site, select and customize a theme, and deploy your site to GitHub and Azure Static Web Apps. We\u0026rsquo;ve also discussed the benefits of using Markdown for better coding syntax support and the simplicity of automating deployments with GitHub Actions.\nAlthough we faced some challenges with the Bicep deployment, using the Azure portal proved to be an effective alternative. Following these steps, you can now focus on creating high-quality content for your blog, knowing that your site is built on a solid foundation.\nI hope this guide has been helpful and inspires you to start your own blog. If you have any questions or run into any issues, feel free to reach out. Happy blogging!\n","permalink":"http://localhost:1313/hugo-PaperMod/posts/20240529/20240529_createblog/","summary":"Overview Since May 2024, I have been a Microsoft MVP in Azure Hybrid and Migration. Many people have asked me, \u0026ldquo;Hey Pratheep, how did you start your blog?\u0026rdquo; To avoid spending too much time on questions like \u0026ldquo;How should my page look?\u0026rdquo; and \u0026ldquo;Which font should I use?\u0026rdquo; I initially published my first blogs on Medium.com. However, I always wanted to create my own blog site.\nRecently, I noticed that some Microsoft-provided websites were using Hugo, a tool I hadn\u0026rsquo;t heard of before.","title":"How to Create Your Own Blog Using Hugo and Azure Static Web Apps"}]